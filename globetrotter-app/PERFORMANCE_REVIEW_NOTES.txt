# GlobeTrotter - Performance Review Notes

## 1. Technical Stack & Justification

We have chosen a modern, robust, and scalable tech stack designed to showcase strong engineering principles, as requested by the hackathon judges.

*   **Architecture:** Monorepo using npm workspaces.
    *   **Why:** This keeps the frontend and backend codebases separate but managed within a single repository, which is a professional standard for full-stack applications.
*   **Backend:**
    *   **Framework:** Node.js with Express.js & TypeScript.
        *   **Why:** A classic, powerful combination for building custom, high-performance REST APIs. TypeScript ensures type safety and code quality.
    *   **Database:** PostgreSQL running in a Docker container.
        *   **Why:** Demonstrates proficiency with containerization and database management, avoiding BaaS solutions like Supabase to highlight core backend skills.
    *   **ORM:** Prisma.
        *   **Why:** Provides a type-safe, intuitive API for database interactions and simplifies schema migrations.
    *   **Authentication:** Custom JWT (JSON Web Tokens) implementation.
        *   **Why:** Shows understanding of authentication flows, password hashing (`bcrypt`), and token-based security from scratch.
*   **Frontend:**
    *   **Framework:** Next.js (App Router) with TypeScript.
        *   **Why:** A leading React framework that offers a great developer experience, server-side rendering for performance, and a clean project structure.
    *   **UI:** Tailwind CSS with Shadcn/UI.
        *   **Why:** Allows for rapid development of a modern, responsive, and accessible user interface by leveraging utility-first CSS and high-quality, unstyled components.

## 2. Project Status & Accomplishments

We have successfully established the complete foundational infrastructure for the application.

*   **Database:** A PostgreSQL database is running successfully in a Docker container. The complete database schema has been designed and migrated using Prisma, creating all necessary tables (`User`, `Trip`, `Stop`, `City`, `Activity`).
*   **Backend API:** A custom Express.js server is built and running.
    *   **Authentication:** The core authentication API is complete. Users can register (`/api/v1/auth/register`) and log in (`/api/v1/auth/login`). The system correctly hashes passwords and issues JWTs upon successful login.
    *   **Trips API:** The foundational endpoints for managing trips are implemented (`POST /api/v1/trips`, `GET /api/v1/trips`, `GET /api/v1/trips/:tripId`).
    *   **Security:** These trip endpoints are protected by a custom authentication middleware that verifies the JWT, ensuring only logged-in users can access their data.
*   **Frontend:** The Next.js client application has been initialized.
    *   **UI Components:** We have set up Shadcn/UI and created a reusable `AuthForm` component for both login and signup, demonstrating component-based architecture.
    *   **Pages:** The `/login` and `/signup` pages are built and ready to be connected to the backend.

**Current Challenge:** We are facing a persistent issue where the Node.js server process crashes silently, preventing the frontend from connecting to it. We have just added enhanced error logging to diagnose this.

## 3. Next Steps (Immediate Plan)

1.  **Stabilize the Server:** The absolute top priority is to diagnose and fix the server crash. The new error handling should reveal the root cause.
2.  **Connect Frontend to Backend:**
    *   Wire up the `AuthForm` on the signup and login pages to the backend API endpoints.
    *   Implement a global state management solution (e.g., React Context) on the client to store the JWT and user authentication status.
3.  **Build Core Trip Management UI:**
    *   Create the main dashboard page to list a user's trips (fetched from `GET /api/v1/trips`).
    *   Build the "Create New Trip" form and connect it to the `POST /api/v1/trips` endpoint.

## 4. Core Logic Implemented

*   **Decoupled Architecture:** The client and server are two separate applications that communicate via a REST API. This is a scalable and maintainable pattern.
*   **Token-Based Authentication:**
    1.  A user registers with an email and password. The password is not stored directly; instead, a secure hash is generated using `bcrypt` and stored in the `User` table.
    2.  When the user logs in, they provide their email and password. The server fetches the user's hash from the database and uses `bcrypt.compare` to check if the provided password is correct.
    3.  If the credentials are valid, the server generates a JWT containing the user's ID and email. This token is signed with a secret key.
    4.  The token is sent back to the client, which is responsible for storing it (e.g., in `localStorage`).
*   **Protected Routes:**
    1.  For any API request to a protected endpoint (like `/api/v1/trips`), the client must include the JWT in the `Authorization` header (e.g., `Authorization: Bearer <token>`).
    2.  The `auth.middleware` on the server intercepts this request, extracts the token, and verifies its signature using the secret key.
    3.  If the token is valid, the middleware decodes the user information from it and attaches it to the `request` object. The request is then allowed to proceed to the actual route handler.
    4.  If the token is missing or invalid, the middleware immediately sends back a `401 Unauthorized` or `403 Forbidden` response, preventing unauthorized access.
